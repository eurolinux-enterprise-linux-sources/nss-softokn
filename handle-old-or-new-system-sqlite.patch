diff -up ./mozilla/security/nss/lib/softoken/config.mk.oldsqlite ./mozilla/security/nss/lib/softoken/config.mk
--- ./mozilla/security/nss/lib/softoken/config.mk.oldsqlite	2012-11-13 20:14:11.000000000 -0500
+++ ./mozilla/security/nss/lib/softoken/config.mk	2013-04-03 18:51:08.448000486 -0400
@@ -10,6 +10,11 @@ EXTRA_LIBS += \
 	$(CRYPTOLIB) \
 	$(NULL)
 
+# system-installed sqlite3 could be old
+ifeq ($(OLD_SQLITE),1)
+DEFINES += -DOLD_SQLITE
+endif
+
 # can't do this in manifest.mn because OS_TARGET isn't defined there.
 ifeq (,$(filter-out WIN%,$(OS_TARGET)))
 
diff -up ./mozilla/security/nss/lib/softoken/sdb.c.oldsqlite ./mozilla/security/nss/lib/softoken/sdb.c
--- ./mozilla/security/nss/lib/softoken/sdb.c.oldsqlite	2013-02-04 14:58:20.000000000 -0500
+++ ./mozilla/security/nss/lib/softoken/sdb.c	2013-04-03 19:01:29.860000486 -0400
@@ -38,6 +38,14 @@
 #include <unistd.h>
 #endif
 
+/* Select the version of the API that we can count on
+ * being available on the system-installed sqlite3. */
+#ifdef OLD_SQLITE
+#define SQLITE3_PREPARE sqlite3_prepare
+#else
+#define SQLITE3_PREPARE sqlite3_prepare_v2
+#endif
+
 #ifdef SQLITE_UNSAFE_THREADS
 #include "prlock.h"
 /*
@@ -259,6 +267,110 @@ sdb_getFallbackTempDir(void)
 #define SQLITE_FCNTL_TEMPFILENAME 16
 #endif
 
+#ifdef OLD_SQLITE
+/*
+ *
+ * strdup limited to 'n' bytes. (Note: len of file is assumed to be >= len)
+ *
+ * We don't have a PORT_ version of this function,
+ * I suspect it's only normally available in glib,
+ */
+static char *
+sdb_strndup(const char *file, int len)
+{
+    char *result = PORT_Alloc(len+1);
+
+    if (result == NULL) {
+     return result;
+    }
+
+    PORT_Memcpy(result, file, len);
+    result[len] = 0;
+    return result;
+}
+
+/*
+ * call back from  sqlite3_exec("Pragma database_list"). Looks for the
+ * temp directory, then return the file the temp directory is stored
+ * at. */
+static int
+sdb_getTempDirCallback(void *arg, int columnCount, char **cval, char
+**cname)
+{
+     int i;
+     int found = 0;
+     char *file = NULL;
+     char *end, *dir;
+     char dirsep;
+
+     /* we've already found the temp directory, don't look at any more
+records*/
+     if (*(char **)arg) {
+     return SQLITE_OK;
+     }
+
+     /* look at the columns to see if this record is the temp database,
+      * and does it say where it is stored */
+     for (i=0; i < columnCount; i++) {
+     if (PORT_Strcmp(cname[i],"name") == 0) {
+         if (PORT_Strcmp(cval[i], "temp") == 0) {
+         found++;
+         continue;
+         }
+     }
+     if (PORT_Strcmp(cname[i],"file") == 0) {
+         if (cval[i] && (*cval[i] != 0)) {
+         file = cval[i];
+         }
+     }
+     }
+
+     /* if we couldn't find it, ask for the next record */
+     if (!found || !file) {
+     return SQLITE_OK;
+     }
+
+     /* drop of the database file name and just return the directory */
+     dirsep = PR_GetDirectorySeparator();
+     end = PORT_Strrchr(file, dirsep);
+     if (!end) {
+     return SQLITE_OK;
+     }
+     dir = sdb_strndup(file, end-file);
+
+     *(char **)arg = dir;
+     return SQLITE_OK;
+}
+
+/*
+ * find out where sqlite stores the temp tables. We do this by creating
+ * a temp table, then looking for the database name that sqlite3 creates.
+ */
+static char *
+sdb_getTempDir(sqlite3 *sqlDB)
+{
+     char *tempDir = NULL;
+     int sqlerr;
+
+     /* create a temporary table */
+     sqlerr = sqlite3_exec(sqlDB, "CREATE TEMPORARY TABLE myTemp (id)",
+               NULL, 0, NULL);
+     if (sqlerr != SQLITE_OK) {
+     return NULL;
+     }
+     /* look for through the database list for the temp directory */
+     sqlerr = sqlite3_exec(sqlDB, "PRAGMA database_list",
+         sdb_getTempDirCallback, &tempDir, NULL);
+
+     /* drop the temp table we created */
+     sqlite3_exec(sqlDB, "DROP TABLE myTemp", NULL, 0, NULL);
+
+     if (sqlerr != SQLITE_OK) {
+     return NULL;
+     }
+     return tempDir;
+}
+#else
 static char *
 sdb_getTempDir(sqlite3 *sqlDB)
 {
@@ -301,6 +413,7 @@ sdb_getTempDir(sqlite3 *sqlDB)
     sqlite3_free(tempName);
     return result;
 }
+#endif
 
 /*
  * Map SQL_LITE errors to PKCS #11 errors as best we can.
@@ -722,7 +835,7 @@ sdb_FindObjectsInit(SDB *sdb, const CK_A
 	error = CKR_HOST_MEMORY;
 	goto loser;
     }
-    sqlerr = sqlite3_prepare_v2(sqlDB, newStr, -1, &findstmt, NULL);
+    sqlerr = SQLITE3_PREPARE(sqlDB, newStr, -1, &findstmt, NULL);
     sqlite3_free(newStr);
     for (i=0; sqlerr == SQLITE_OK && i < count; i++) {
 	const void *blobData = template[i].pValue;
@@ -861,7 +974,7 @@ sdb_GetAttributeValueNoLock(SDB *sdb, CK
 	    goto loser;
 	}
 
-	sqlerr = sqlite3_prepare_v2(sqlDB, newStr, -1, &stmt, NULL);
+	sqlerr = SQLITE3_PREPARE(sqlDB, newStr, -1, &stmt, NULL);
 	sqlite3_free(newStr);
 	newStr = NULL;
 	if (sqlerr == SQLITE_ERROR) {
@@ -1002,7 +1115,7 @@ sdb_SetAttributeValue(SDB *sdb, CK_OBJEC
     if (error != CKR_OK) {
 	goto loser;
     }
-    sqlerr = sqlite3_prepare_v2(sqlDB, newStr, -1, &stmt, NULL);
+    sqlerr = SQLITE3_PREPARE(sqlDB, newStr, -1, &stmt, NULL);
     if (sqlerr != SQLITE_OK) goto loser;
     for (i=0; i < count; i++) {
 	if (template[i].ulValueLen != 0) {
@@ -1161,7 +1274,7 @@ sdb_CreateObject(SDB *sdb, CK_OBJECT_HAN
     if (error != CKR_OK) {
 	goto loser;
     }
-    sqlerr = sqlite3_prepare_v2(sqlDB, newStr, -1, &stmt, NULL);
+    sqlerr = SQLITE3_PREPARE(sqlDB, newStr, -1, &stmt, NULL);
     if (sqlerr != SQLITE_OK) goto loser;
     sqlerr = sqlite3_bind_int(stmt, 1, *object_id);
     if (sqlerr != SQLITE_OK) goto loser;
@@ -1230,7 +1343,7 @@ sdb_DestroyObject(SDB *sdb, CK_OBJECT_HA
 	error = CKR_HOST_MEMORY;
 	goto loser;
     }
-    sqlerr =sqlite3_prepare_v2(sqlDB, newStr, -1, &stmt, NULL);
+    sqlerr = SQLITE3_PREPARE(sqlDB, newStr, -1, &stmt, NULL);
     sqlite3_free(newStr);
     if (sqlerr != SQLITE_OK) goto loser;
     sqlerr =sqlite3_bind_int(stmt, 1, object_id);
@@ -1293,7 +1406,7 @@ sdb_Begin(SDB *sdb)
 	goto loser;
     }
 
-    sqlerr =sqlite3_prepare_v2(sqlDB, BEGIN_CMD, -1, &stmt, NULL);
+    sqlerr = SQLITE3_PREPARE(sqlDB, BEGIN_CMD, -1, &stmt, NULL);
 
     do {
 	sqlerr = sqlite3_step(stmt);
@@ -1372,7 +1485,7 @@ sdb_complete(SDB *sdb, const char *cmd)
     sdb_p->sqlXactThread = NULL; 
     PR_ExitMonitor(sdb_p->dbMon);
 
-    sqlerr =sqlite3_prepare_v2(sqlDB, cmd, -1, &stmt, NULL);
+    sqlerr = SQLITE3_PREPARE(sqlDB, cmd, -1, &stmt, NULL);
 
     do {
 	sqlerr = sqlite3_step(stmt);
@@ -1447,7 +1560,7 @@ sdb_GetMetaData(SDB *sdb, const char *id
     }
 
     /* handle 'test' versions of the sqlite db */
-    sqlerr = sqlite3_prepare_v2(sqlDB, GET_PW_CMD, -1, &stmt, NULL);
+    sqlerr = SQLITE3_PREPARE(sqlDB, GET_PW_CMD, -1, &stmt, NULL);
     /* Sigh, if we created a new table since we opened the database,
      * the database handle will not see the new table, we need to close this
      * database and reopen it. This is safe because we are holding the lock
@@ -1457,7 +1570,7 @@ sdb_GetMetaData(SDB *sdb, const char *id
 	if (sqlerr != SQLITE_OK) {
 	    goto loser;
 	}
-	sqlerr = sqlite3_prepare_v2(sqlDB, GET_PW_CMD, -1, &stmt, NULL);
+	sqlerr = SQLITE3_PREPARE(sqlDB, GET_PW_CMD, -1, &stmt, NULL);
     }
     if (sqlerr != SQLITE_OK) goto loser;
     sqlerr = sqlite3_bind_text(stmt, 1, id, PORT_Strlen(id), SQLITE_STATIC);
@@ -1547,7 +1660,7 @@ sdb_PutMetaData(SDB *sdb, const char *id
     if (item2 == NULL) {
 	cmd = MD_CREATE_CMD;
     }
-    sqlerr = sqlite3_prepare_v2(sqlDB, cmd, -1, &stmt, NULL);
+    sqlerr = SQLITE3_PREPARE(sqlDB, cmd, -1, &stmt, NULL);
     if (sqlerr != SQLITE_OK) goto loser;
     sqlerr = sqlite3_bind_text(stmt, 1, id, PORT_Strlen(id), SQLITE_STATIC);
     if (sqlerr != SQLITE_OK) goto loser;
